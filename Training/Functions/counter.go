package main

import "fmt"

func counterasd() (func() int, error) { // здесь функция counterasd() возвращает другую функцию func() int {}
	i := 0              // переменная, замкнутая в области видимости функции func() int {....}
	return func() int { //Здесь мы не вызываем функцию (чтобы вызвать функцию нужно написать круглые скобочки (), а содаем ее, но одновременно пишем команду что мы ретерним. команда ретерн и создание функции одновременно, но ретерн и создание функции это разные операции, они не имет нтношения друг к другу
		i++
		return i
	}, nil
}

//func counterasd() func() int { // здесь функция counterasd() возвращает другую функцию func() int {}
//	i := 0 // переменная, замкнутая в области видимости функции func() int {....}
//	myfunc_which_I_want_to_return := func() int {
//		i++
//		return i
//	}
//	return myfunc_which_I_want_to_return
//}

func main() {
	increment, _ := counterasd() // создаем замыкание   "_" - это игнорирование возвращаемого значения. Типа мы говорим что мы знаем что она возвращает два значения, но нам не важно второе, это пишется чтобы соблюсти контракт (это штука которую обязуются выполнять 2 стороны - каунтерасд обязуется вернуть 2 значекния, принммающая сторона обязуется принять тоже 2 знаенчения
	ptr := &increment
	fmt.Println(ptr)         // ячейка стека, где лежит переменная инкремент - ячейка стека - выводится шестнадцатиричный вид чисел указателя
	fmt.Println(&increment)  // тоже адрес ячейки стека, где лежит переменная инкремент - ячейка стека
	fmt.Println(increment)   // тоже ячейка стека, где лежит адрес функции func() int - ячейка стека
	fmt.Println(&ptr)        // ячейка стека, где лежит переменная ptr, переменные функций и ссылочные типы хранятся в куче, недолговечные элементы - в стеке.
	fmt.Println(increment)   // ячейка стека, где лежит адрес функции func() int
	fmt.Println(increment()) // здесь круглые скобки после increment означают, что инкремент относится к функции (согласно коду) и фигур.скобки вызывают эту функцию, без них функция не запустится. Без кругл.скобок выведется указатель на функцию, как в предыдущей строке.
	fmt.Println(increment())
	fmt.Println(increment())
	fmt.Println(increment())
	fmt.Println(increment())
	fmt.Println()
	newCounter, _ := counterasd() // новый счетчик, независимый от первого
	fmt.Println(newCounter())
	fmt.Println(newCounter())
	fmt.Println(newCounter())
}

// Стек — это область памяти, в которой функции хранят свои переменные и информацию, необходимую для выполнения. Когда вызывается функция, её локальные
// переменные и информация о вызове помещаются на вершину стека, а при завершении функции эти данные удаляются с вершины.
// Куча используется для хранения данных, которые должны существовать дольше времени выполнения функции, или для работы с большими объёмами
// данных. В отличие от стека, где данные удаляются автоматически после завершения функции, данные в куче остаются, пока не будут явно удалены.
// Таким образом, стек используется для управления временными данными, которые должны быть обработаны в определённом порядке, в то
// время как куча — для хранения данных, которые должны быть доступны в течение всей программы.
